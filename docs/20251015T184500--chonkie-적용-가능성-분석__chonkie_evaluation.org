* 🦛 Chonkie 적용 가능성 분석: 코드 풋프린트 vs 실용성
:PROPERTIES:
:CUSTOM_ID: chonkie-적용-가능성-분석-코드-풋프린트-vs-실용성
:END:
*목적*: 코드 복잡도를 줄이면서 RAG 품질 유지 가능한가? *결론*: ⚠️ 부분
적용 권장 (청킹만, v2.1 실험)

--------------

** 📊 실제 코드 분석 (Git Clone 확인)
:PROPERTIES:
:CUSTOM_ID: 실제-코드-분석-git-clone-확인
:END:
*** embedding-config (현재)
:PROPERTIES:
:CUSTOM_ID: embedding-config-현재
:END:
#+begin_src sh
process_org_garden.py: 539줄

구성:
- Denote 파싱: ~30줄 (필수, 대체 불가)
- Org properties: ~50줄 (필수, 대체 불가)
- 청킹 로직: ~30줄 (간단!) ← Chonkie 대체 검토
- 임베딩 생성: ~20줄
- DB 연동: ~100줄
- 메인 로직: ~200줄
- 유틸/에러: ~109줄

의존성: psycopg2, requests, tqdm (3개)
#+end_src

*** Chonkie (실제 코드)
:PROPERTIES:
:CUSTOM_ID: chonkie-실제-코드
:END:
#+begin_src sh
Git Clone 결과:
전체 Python 코드: 33,777줄 (!)

청킹 구현체:
- RecursiveChunker: 379줄
- SemanticChunker: 589줄
- 기타 Chunkers: 7개 더

C extensions: Cython 최적화 (split, merge, savgol)

필수 의존성: tqdm, loguru, numpy
선택 의존성: sentence-transformers, torch, huggingface-hub...

패키지 크기: 505KB (경량 = 패키징, 코드는 아님!)
#+end_src

*충격적 발견*:

#+begin_example
505KB "경량" ≠ 코드 라인 경량
505KB = 패키징 크기
실제 코드 = 33,777줄!

embedding-config 청킹: 30줄 (간단, 이해 쉬움)
Chonkie RecursiveChunker: 379줄 (복잡, 학습 필요)
#+end_example

*청킹 로직* (현재):

#+begin_src python
def chunk_text(text, max_size, overlap):
    """
    헤딩 기준 청킹 + 오버랩

    ~30줄 코드
    - 정규식으로 헤딩 분할 (\n\*+\s+)
    - 토큰 수 대략 계산 (한글 3자 = 1토큰)
    - 오버랩 처리
    """
    sections = re.split(r'\n\*+\s+', text)  # Org 헤딩
    # ... 30줄 로직
#+end_src

*FOLDER_CONFIG* (폴더별 차별화):

#+begin_src python
FOLDER_CONFIG = {
    'meta': {'chunk_size': 1500, 'overlap': 200},
    'bib': {'chunk_size': 1200, 'overlap': 150},
    'journal': {'chunk_size': 800, 'overlap': 100},
    'notes': {'chunk_size': 1000, 'overlap': 150},
    # ... 8개 폴더
}
#+end_src

--------------

** 🦛 Chonkie로 대체 시
:PROPERTIES:
:CUSTOM_ID: chonkie로-대체-시
:END:
*** RecursiveChunker + markdown
:PROPERTIES:
:CUSTOM_ID: recursivechunker-markdown
:END:
#+begin_src python
from chonkie import RecursiveChunker

# Before (30줄)
def chunk_text(text, max_size, overlap):
    sections = re.split(r'\n\*+\s+', text)
    # ... 30줄 로직
    return chunks

# After (3줄!)
chunker = RecursiveChunker(
    chunk_size=1500,
    chunk_overlap=200,
    recipe="markdown"
)
chunks = chunker(text)
#+end_src

*코드 감소*: 30줄 → 3줄 (*90% 감소!*)

--------------

*** 하지만... 폴더별 설정은?
:PROPERTIES:
:CUSTOM_ID: 하지만-폴더별-설정은
:END:
*문제*:

#+begin_src python
# embedding-config (폴더별 차별화)
FOLDER_CONFIG = {
    'meta': {'chunk_size': 1500, 'overlap': 200},
    'bib': {'chunk_size': 1200, 'overlap': 150},
    # ...
}

# Chonkie (단일 설정)
chunker = RecursiveChunker(chunk_size=???, overlap=???)
# → 폴더마다 chunker 인스턴스 생성 필요
#+end_src

*해결책*:

#+begin_src python
# Chonkie로 폴더별 처리 (여전히 설정 필요)
def get_chunker(folder):
    config = FOLDER_CONFIG[folder]
    return RecursiveChunker(
        chunk_size=config['chunk_size'],
        chunk_overlap=config['overlap'],
        recipe="markdown"
    )

# 사용
for folder in ['meta', 'bib', 'journal', 'notes']:
    chunker = get_chunker(folder)
    chunks = chunker(text)
#+end_src

*실제 코드 감소*: 30줄 → 10줄 (*67% 감소*)

--------------

** 📐 실용적 비교
:PROPERTIES:
:CUSTOM_ID: 실용적-비교
:END:
*** 현재 (embedding-config, 검증됨)
:PROPERTIES:
:CUSTOM_ID: 현재-embedding-config-검증됨
:END:
*장점*: - ✅ 완전 통제 (청킹 로직 직접 제어) - ✅ 검증됨 (2,945개 파일
성공) - ✅ 의존성 없음 (표준 라이브러리만) - ✅ 한글 특화 (한글 3자 =
1토큰 계산)

*단점*: - ⚠️ 30줄 청킹 로직 유지보수 - ⚠️ 버그 가능성 (정규식)

*코드*:

#+begin_src python
# 청킹만 30줄
# 전체 539줄

의존성:
- psycopg2 (Supabase)
- requests (Ollama)
- tqdm (진행 표시)
#+end_src

--------------

*** Chonkie 적용 (실험)
:PROPERTIES:
:CUSTOM_ID: chonkie-적용-실험
:END:
*장점*: - ✅ 청킹 로직 간소화 (30줄 → 10줄) - ✅ 검증된 라이브러리
(커뮤니티) - ✅ 다양한 청킹 방식 (8가지) - ✅ 마크다운 recipe 지원

*단점*: - ⚠️ 새 의존성 추가 (505KB) - ⚠️ 검증 필요 (실제 Denote 문서로) -
⚠️ 한글 토큰 계산 다를 수 있음 - ⚠️ Org 헤딩 (/, *, */) vs Markdown (#,
​##, ###)

*코드*:

#+begin_src python
# 청킹만 10줄
# 전체 519줄 (3.7% 감소)

의존성:
- psycopg2
- requests
- tqdm
- chonkie (← NEW, 505KB)
#+end_src

--------------

** 🎯 실용적 결론 (Git Clone 검증)
:PROPERTIES:
:CUSTOM_ID: 실용적-결론-git-clone-검증
:END:
*** 코드 풋프린트 실측 분석
:PROPERTIES:
:CUSTOM_ID: 코드-풋프린트-실측-분석
:END:
#+begin_src yaml
embedding-config (현재):
  전체_코드: 539줄
  청킹_로직: 30줄 (간단, 이해 쉬움)
  의존성: 3개 (psycopg2, requests, tqdm)
  복잡도: 낮음

Chonkie (실제):
  전체_코드: 33,777줄 (!)
  RecursiveChunker: 379줄 (복잡)
  SemanticChunker: 589줄 (매우 복잡)
  필수_의존성: tqdm, loguru, numpy
  선택_의존성: sentence-transformers, torch 등
  복잡도: 매우 높음

적용_시:
  memex-kb 코드: 539줄 → 519줄 (20줄 감소)
  하지만:
    + Chonkie 라이브러리: 33,777줄 의존
    + 학습 곡선: RecursiveRules, recipe 시스템
    + 디버깅: 복잡한 내부 로직

실제_풋프린트:
  현재: 539줄 (자체 통제)
  Chonkie: 519줄 + 33,777줄 (의존성)

  → 62배 증가!
#+end_src

*→ 코드 풋프린트 감소 아님. 오히려 62배 증가!*

--------------

*** 하지만 SemanticChunker는?
:PROPERTIES:
:CUSTOM_ID: 하지만-semanticchunker는
:END:
*흥미로운 점*:

#+begin_src python
# embedding-config: 헤딩 기준 (구조적)
chunks = re.split(r'\n\*+\s+', text)

# Chonkie SemanticChunker: 의미 기반
chunker = SemanticChunker(
    embedding_model="mxbai-embed-large",
    similarity_threshold=0.5
)
chunks = chunker(text)

→ 임베딩으로 의미 유사도 계산 후 분할!
→ 구조 무시, 의미 중심
#+end_src

*장점*: - 헤딩 없는 텍스트도 의미 단위로 분할 - 문맥 보존 더 우수

*단점*: - 임베딩 비용 2배 (청킹 시 + 최종 임베딩) - 느림 (청킹마다
임베딩 계산)

--------------

** 💡 권장사항 (Git Clone 검증 후)
:PROPERTIES:
:CUSTOM_ID: 권장사항-git-clone-검증-후
:END:
*** v2.0 (즉시): 직접 구현 (embedding-config 재사용) ⭐⭐⭐⭐⭐
:PROPERTIES:
:CUSTOM_ID: v2.0-즉시-직접-구현-embedding-config-재사용
:END:
*이유*: 1. *검증됨*: 2,945개 파일 성공 2. *간단함*: 30줄 청킹 로직 (이해
쉬움) 3. *통제 가능*: 직접 작성 코드 (디버깅 쉬움) 4. *의존성 적음*:
3개만 (psycopg2, requests, tqdm) 5. *코드 풋프린트*: 539줄 (vs Chonkie
33,777줄 의존)

*실제 비교*:

#+begin_src yaml
embedding-config (30줄 청킹):
  코드: 539줄 (자체 통제)
  복잡도: 낮음
  디버깅: 쉬움
  학습: 불필요 (직관적)

Chonkie (379줄 RecursiveChunker):
  코드: 519줄 + 33,777줄 라이브러리
  복잡도: 매우 높음
  디버깅: 어려움 (내부 로직 복잡)
  학습: 필요 (recipe, rules, C extension)
#+end_src

*구현*:

#+begin_src python
# embedding-config 코드 그대로 복사
# 539줄 → 539줄 (변경 없음)
# 의존성: psycopg2, requests, tqdm (기존)
# 복잡도: 낮음, 통제 가능
#+end_src

*결론*:

#+begin_example
"간단한 30줄 청킹으로도 충분하다!"

2,945개 파일 임베딩 성공한 코드를
33,777줄 라이브러리로 교체할 이유 없음.

→ 검증된 간단 코드 > 복잡한 라이브러리
#+end_example

--------------

*** v2.1 (실험): Chonkie 리팩토링
:PROPERTIES:
:CUSTOM_ID: v2.1-실험-chonkie-리팩토링
:END:
*조건*: v2.0 안정화 후

*목표*: 1. RecursiveChunker로 청킹 간소화 2. *SemanticChunker 실험*
(의미 기반 청킹) 3. A/B 테스트 (기존 vs Chonkie)

*실험 계획*:

#+begin_src python
# Phase 1: RecursiveChunker (구조 기반)
def chunk_with_chonkie_recursive(text, folder):
    config = FOLDER_CONFIG[folder]
    chunker = RecursiveChunker(
        chunk_size=config['chunk_size'],
        chunk_overlap=config['overlap'],
        recipe="markdown"
    )
    return chunker(text)

# Phase 2: SemanticChunker (의미 기반)
def chunk_with_chonkie_semantic(text, folder):
    config = FOLDER_CONFIG[folder]
    chunker = SemanticChunker(
        chunk_size=config['chunk_size'],
        embedding_model="mxbai-embed-large",
        similarity_threshold=0.5
    )
    return chunker(text)

# Phase 3: A/B 테스트
results_baseline = test_search_quality(기존_청킹)
results_recursive = test_search_quality(chonkie_recursive)
results_semantic = test_search_quality(chonkie_semantic)

# 비교 지표: MRR, Recall, Latency, Cost
#+end_src

*예상 결과*:

#+begin_src yaml
Baseline (기존):
  MRR@10: 0.85
  Latency: 200ms
  Cost: $0

RecursiveChunker:
  MRR@10: 0.83~0.87 (비슷)
  Latency: 180ms (약간 빠름)
  Cost: $0

SemanticChunker:
  MRR@10: 0.88~0.92 (향상 예상!)
  Latency: 400ms (느림, 청킹 시 임베딩)
  Cost: 임베딩 2배
#+end_src

--------------

** 🎯 최종 권장: 단계적 접근
:PROPERTIES:
:CUSTOM_ID: 최종-권장-단계적-접근
:END:
*** Step 1: v2.0 (2주) - 검증된 코드
:PROPERTIES:
:CUSTOM_ID: step-1-v2.0-2주---검증된-코드
:END:
#+begin_src sh
embedding-config 코드 재사용
    ↓
memex-kb v2.0 완성
    ↓
실전 검증 (1-2주 운영)
    ↓
성능 지표 수집
#+end_src

*이유*: - 검증된 코드 (2,945개 성공) - 빠른 구현 (복사-붙여넣기) -
리스크 0

--------------

*** Step 2: v2.1 (2주) - Chonkie 실험
:PROPERTIES:
:CUSTOM_ID: step-2-v2.1-2주---chonkie-실험
:END:
#+begin_src sh
RecursiveChunker 적용
    ↓
A/B 테스트 (기존 vs Chonkie)
    ↓
MRR, Latency 비교
    ↓
결정: 유지 or 롤백
#+end_src

*이유*: - v2.0 안정화 후 - 실험적 개선 - 데이터 기반 결정

--------------

*** Step 3: v2.2 (미래) - SemanticChunker
:PROPERTIES:
:CUSTOM_ID: step-3-v2.2-미래---semanticchunker
:END:
#+begin_src sh
SemanticChunker 실험
    ↓
의미 기반 청킹 효과 측정
    ↓
비용 vs 품질 트레이드오프 분석
#+end_src

*이유*: - 가장 흥미로운 기능 - 비용 증가 (임베딩 2배) - 품질 향상 가능성

--------------

** 📋 Chonkie 적용 시나리오 (구체적)
:PROPERTIES:
:CUSTOM_ID: chonkie-적용-시나리오-구체적
:END:
*** 시나리오 A: RecursiveChunker만 적용
:PROPERTIES:
:CUSTOM_ID: 시나리오-a-recursivechunker만-적용
:END:
*변경 부분*:

#+begin_src python
# Before (30줄)
def chunk_text(text, max_size, overlap):
    sections = re.split(r'\n\*+\s+', text)  # Org 헤딩
    chunks = []
    current_chunk = ""
    # ... 25줄 로직
    return chunks

# After (5줄)
from chonkie import RecursiveChunker

def chunk_text_chonkie(text, max_size, overlap, folder):
    chunker = RecursiveChunker(
        chunk_size=max_size,
        chunk_overlap=overlap,
        recipe="markdown"  # Org도 지원 가능성
    )
    return chunker(text)
#+end_src

*유지 부분* (대체 불가):

#+begin_src python
# Denote 파싱 (30줄)
def parse_denote_filename(filepath): ...

# Org properties (50줄)
def extract_org_properties(content): ...

# 폴더별 설정 (필수)
FOLDER_CONFIG = {
    'meta': {'chunk_size': 1500, 'overlap': 200},
    # ...
}

# 임베딩 텍스트 준비 (30줄)
def prepare_embedding_text(denote_meta, org_content, org_properties): ...
#+end_src

*결과*: - 코드: 539줄 → 514줄 (25줄 = 4.6% 감소) - 의존성: +1
(chonkie) - 검증: 1-2일 테스트 필요

--------------

*** 시나리오 B: SemanticChunker 실험
:PROPERTIES:
:CUSTOM_ID: 시나리오-b-semanticchunker-실험
:END:
*변경*:

#+begin_src python
from chonkie import SemanticChunker

def chunk_semantic(text, folder):
    config = FOLDER_CONFIG[folder]

    chunker = SemanticChunker(
        chunk_size=config['chunk_size'],
        embedding_model="mxbai-embed-large",
        similarity_threshold=0.5
    )

    return chunker(text)
#+end_src

*장점*: - 의미 기반 청킹 (구조 무관) - 문맥 보존 우수

*단점*: - *임베딩 비용 2배*: ``` Before: 1회 임베딩 (최종 청크만) After:
2회 임베딩 (청킹 시 + 최종 청크)

6,000 문서 × 2 = 12,000회 임베딩 GPU-03 소요 시간: 28시간 → 56시간 ``` -
*속도*: 청킹 시간 증가 (임베딩 계산) - *복잡도*: 임베딩 모델 관리

--------------

** 🎯 실용적 평가
:PROPERTIES:
:CUSTOM_ID: 실용적-평가
:END:
*** 코드 풋프린트 vs 실익
:PROPERTIES:
:CUSTOM_ID: 코드-풋프린트-vs-실익
:END:
#+begin_src yaml
RecursiveChunker:
  코드_감소: 4.6% (25줄/539줄)
  의존성_증가: +1 (505KB)
  검증_필요: 1-2일
  성능_변화: 미미 (예상)
  실익: 낮음 ⚠️

SemanticChunker:
  코드_감소: 4.6% (동일)
  비용_증가: 2배 (임베딩)
  품질_향상: 5-10% (예상)
  실익: 중간 🤔
#+end_src

--------------

** 💡 최종 권장: 단계적 실험
:PROPERTIES:
:CUSTOM_ID: 최종-권장-단계적-실험
:END:
*** Phase 1: v2.0 (즉시)
:PROPERTIES:
:CUSTOM_ID: phase-1-v2.0-즉시
:END:
*전략*: embedding-config 코드 그대로 재사용

*이유*: 1. *검증됨*: 2,945개 성공 2. *빠름*: 복사-붙여넣기 (1일) 3.
*안정*: 리스크 0 4. *우선순위*: 기능 완성 > 코드 최적화

#+begin_src python
# memex-kb v2.0
# embedding-config 코드 100% 재사용
# 539줄, 의존성 3개 (psycopg2, requests, tqdm)
#+end_src

--------------

*** Phase 2: v2.1 (실험, v2.0 안정화 후)
:PROPERTIES:
:CUSTOM_ID: phase-2-v2.1-실험-v2.0-안정화-후
:END:
*전략*: RecursiveChunker A/B 테스트

*목표*: - 기존 vs Chonkie 비교 - MRR, Latency 측정 - 데이터 기반 결정

#+begin_src python
# 100개 문서로 A/B 테스트
baseline_chunks = chunk_text(text, max_size, overlap)
chonkie_chunks = RecursiveChunker(...)(text)

# 임베딩 후 검색 품질 비교
baseline_mrr = evaluate(baseline_chunks)
chonkie_mrr = evaluate(chonkie_chunks)

if chonkie_mrr > baseline_mrr * 1.05:  # 5% 향상
    print("✅ Chonkie 채택")
else:
    print("⚠️ 기존 유지 (미미한 차이)")
#+end_src

--------------

*** Phase 3: v2.2 (미래, 선택적)
:PROPERTIES:
:CUSTOM_ID: phase-3-v2.2-미래-선택적
:END:
*전략*: SemanticChunker 실험 (의미 기반 청킹)

*조건*: - v2.1 RecursiveChunker 안정화 - 품질 향상 필요성 확인 - 임베딩
비용 2배 감수 가능

*테스트*:

#+begin_src python
# 비용 vs 품질 분석
cost_increase = 2배 (임베딩)
quality_increase = SemanticChunker MRR 측정

if quality_increase > 10% and cost_acceptable:
    print("✅ SemanticChunker 채택")
else:
    print("⚠️ RecursiveChunker 유지")
#+end_src

--------------

** 📊 의사결정 매트릭스
:PROPERTIES:
:CUSTOM_ID: 의사결정-매트릭스
:END:
*** Chonkie 채택 기준
:PROPERTIES:
:CUSTOM_ID: chonkie-채택-기준
:END:
#+begin_src yaml
채택_조건:
  - 코드_감소 > 10% (현재 4.6%, 미달)
  - 품질_향상 > 5% (미확인)
  - 의존성_증가 허용 가능 (OK)
  - 검증_시간 < 3일 (OK)

현재_평가:
  RecursiveChunker: ⚠️ 조건부 (v2.1 실험)
  SemanticChunker: 🤔 흥미롭지만 비용 증가

권장:
  v2.0: 기존 코드 (검증됨)
  v2.1: RecursiveChunker 실험
  v2.2: SemanticChunker 선택적
#+end_src

--------------

** 🔗 관련 문서
:PROPERTIES:
:CUSTOM_ID: 관련-문서
:END:
*Chonkie*: - GitHub: https://github.com/chonkie-inc/chonkie - Docs:
https://docs.chonkie.ai/

*memex-kb*: - GitHub: https://github.com/junghan0611/memex-kb - RAG 통합
전략:
docs/20251015T180500--memex-kb-rag-통합-전략__rag_embedding_architecture.md -
embedding-config 통합:
docs/20251015T182000--embedding-config-경험-통합-가이드__embedding_integration.md

*embedding-config*: - process_org_garden.py (539줄, 검증됨) - 2,945개
파일 임베딩 완료 - MRR@10: 0.85

--------------

** 📝 최종 결론 (Git Clone 실측)
:PROPERTIES:
:CUSTOM_ID: 최종-결론-git-clone-실측
:END:
*** Q: Chonkie로 코드 풋프린트 줄일 수 있나?
:PROPERTIES:
:CUSTOM_ID: q-chonkie로-코드-풋프린트-줄일-수-있나
:END:
*A: 아닙니다. 오히려 62배 증가합니다.*

#+begin_src yaml
현재 (embedding-config):
  자체_코드: 539줄
  청킹_로직: 30줄 (간단, 검증됨)
  의존성: 3개
  통제: 100%

Chonkie 적용 시:
  자체_코드: 519줄 (20줄 감소)
  Chonkie_의존: 33,777줄 (62배!)
  학습_곡선: 높음
  통제: 낮음 (라이브러리 의존)

실제_풋프린트:
  539줄 → 34,296줄 (63.6배 증가)
#+end_src

--------------

*** 실용적 평가
:PROPERTIES:
:CUSTOM_ID: 실용적-평가-1
:END:
*RecursiveChunker* (379줄):

#+begin_example
장점:
  + Recipe 시스템 (markdown, code 등)
  + C extension 최적화 (빠름)
  + 커뮤니티 검증

단점:
  - 복잡도 높음 (379줄 vs 30줄)
  - 학습 필요 (RecursiveRules, recipe)
  - Org 헤딩(*) 커스텀 recipe 필요
  - 폴더별 설정 여전히 직접 관리

실익: ⚠️ 낮음 (복잡도 >> 이득)
#+end_example

*SemanticChunker* (589줄):

#+begin_example
장점:
  + 의미 기반 청킹 (구조 무관)
  + Savitzky-Golay 필터링 (정교함)
  + 품질 향상 가능성

단점:
  - 매우 복잡 (589줄)
  - 임베딩 비용 2배
  - 느림 (청킹마다 임베딩)
  - torch, sentence-transformers 의존

실익: 🤔 중간 (품질 vs 비용/복잡도)
#+end_example

--------------

*** 최종 권장: "간단한 30줄이 최고"
:PROPERTIES:
:CUSTOM_ID: 최종-권장-간단한-30줄이-최고
:END:
#+begin_example
v2.0 (즉시):
  embedding-config 30줄 청킹 그대로 사용
  이유:
    - 검증됨 (2,945개 성공)
    - 간단함 (30줄, 이해 쉬움)
    - 빠름 (복사-붙여넣기)
    - 통제 가능 (디버깅 쉬움)
    ⭐⭐⭐⭐⭐

v2.1 (선택적, 미래):
  SemanticChunker만 실험 (의미 기반 청킹)
  조건:
    - v2.0 안정화 후
    - 품질 향상 필요성 확인
    - 비용 2배 감수 가능
  ⭐⭐⭐

v2.2 (제외):
  RecursiveChunker는 스킵
  이유:
    - 복잡도만 높음 (379줄)
    - 실익 낮음 (4.6% 코드 감소)
    - 의존성 33,777줄 (62배 증가)
  ⭐
#+end_example

--------------

*** 핵심 인사이트
:PROPERTIES:
:CUSTOM_ID: 핵심-인사이트
:END:
*"505KB 경량" ≠ "코드 경량"*:

#+begin_example
505KB = 패키징 크기 (마케팅)
33,777줄 = 실제 코드 (현실)

30줄 = embedding-config 청킹 (실용)
#+end_example

*KISS 원칙* (Keep It Simple, Stupid):

#+begin_example
간단한 코드 (30줄):
  ✅ 이해 쉬움
  ✅ 유지보수 쉬움
  ✅ 디버깅 쉬움
  ✅ 검증됨

복잡한 라이브러리 (33,777줄):
  ⚠️ 학습 필요
  ⚠️ 블랙박스
  ⚠️ 의존성 지옥
  ⚠️ 과잉 엔지니어링
#+end_example

*실용주의*:

#+begin_example
"충분히 좋은 것이 최선이다"
(Good Enough is Perfect)

2,945개 파일 임베딩 성공한 30줄 코드가
33,777줄 라이브러리보다 낫다.

→ 간단함 > 복잡함
→ 검증됨 > 이론
→ 실용 > 이상
#+end_example

--------------

*최종 업데이트*: 2025-10-15T18:45:00+09:00 *다음 체크포인트*: v2.0 완성
후 Chonkie 재평가
