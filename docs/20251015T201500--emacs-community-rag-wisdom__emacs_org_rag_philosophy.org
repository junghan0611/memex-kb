* 🧠 Emacs Org-mode RAG 통합 전략: 한글 환경 특화
:PROPERTIES:
:CUSTOM_ID: emacs-org-mode-rag-통합-전략-한글-환경-특화
:END:
*목적*: Org-mode 지식베이스 먼저 고도화 → 경험 검증 → memex-kb 역적용
*접근*: Emacs 커뮤니티 지혜 + 한글 특화 + 실전 경험

--------------

** 🎯 전략 전환: "Org-mode 우선"
:PROPERTIES:
:CUSTOM_ID: 전략-전환-org-mode-우선
:END:
*** Before (memex-kb 중심)
:PROPERTIES:
:CUSTOM_ID: before-memex-kb-중심
:END:
#+begin_example
Legacy 문서 → memex-kb 변환 → Denote → 임베딩 → RAG

문제:
  - Legacy 문서 변환은 "감흥 없음"
  - 검증 없이 설계만
  - 자신의 지식베이스 활용 안 됨
#+end_example

*** After (Org-mode 우선)
:PROPERTIES:
:CUSTOM_ID: after-org-mode-우선
:END:
#+begin_example
~/org/ (1,400+ 파일)
    ↓ Emacs 커뮤니티 전략 적용
실험 & 검증 (실전 경험)
    ↓ 한글 환경 최적화
나만의 전략 확립
    ↓ 역적용
memex-kb v2.0 (검증된 방법론)

가치:
  ✅ 자신의 지식베이스 즉시 활용
  ✅ 실전 경험 기반
  ✅ 한글 환경 고려
  ✅ 검증 후 memex-kb에 적용
#+end_example

--------------

** 📊 Emacs 커뮤니티 전문가 분석 (종합)
:PROPERTIES:
:CUSTOM_ID: emacs-커뮤니티-전문가-분석-종합
:END:

--------------

** 🔍 발견한 프로젝트 (5개)
:PROPERTIES:
:CUSTOM_ID: 발견한-프로젝트-5개
:END:
*** 1. *ELISA* (s-kostyaev) ⭐⭐⭐⭐⭐
:PROPERTIES:
:CUSTOM_ID: elisa-s-kostyaev
:END:
*GitHub*: https://github.com/s-kostyaev/elisa

*청킹 전략* (핵심!):

#+begin_src elisp
;; elisa.el (line 638-644, 697-729)

(defun elisa-split-by-paragraph ()
  "Split buffer to list of paragraphs."
  (elisa--split-by #'forward-paragraph))

(defun elisa-split-semantically ()
  "Split buffer data semantically."
  ;; 1. Paragraph로 청킹
  (let* ((chunks (elisa-split-by-paragraph))
         ;; 2. 모든 청크 임베딩
         (embeddings (elisa-embeddings chunks))
         ;; 3. Cosine distance 계산
         (distances (elisa--distances embeddings))
         ;; 4. Threshold 기반 병합
         (threshold (elisa-calculate-threshold k distances)))
    ;; distance <= threshold이면 병합
    ;; distance > threshold이면 분리
    ...))
#+end_src

*핵심*: - *간단함*: forward-paragraph 사용 (Emacs 내장) - *의미 기반*:
Cosine distance로 병합 판단 - *~30줄*: 전체 청킹 로직 - *통제 가능*:
직관적, 디버깅 쉬움

*Hybrid Search* (SQL로!):

#+begin_src sql
-- elisa.el (line 573-609)

WITH
vector_search AS (
  SELECT rowid, distance FROM data_embeddings
  WHERE vss_search(embedding, query_embedding)
  ORDER BY distance ASC LIMIT 40
),
keyword_search AS (
  SELECT rowid, RANK () OVER (ORDER BY bm25(data_fts) ASC)
  FROM data_fts WHERE data_fts MATCH query
  ORDER BY bm25(data_fts) ASC LIMIT 20
),
hybrid_search AS (
  SELECT
    COALESCE(semantic_search.rowid, keyword_search.rowid) AS rowid,
    COALESCE(1.0 / (60 + semantic_search.rank), 0.0) +
    COALESCE(1.0 / (60 + keyword_search.rank), 0.0) AS score
  FROM semantic_search
  FULL OUTER JOIN keyword_search
  ORDER BY score DESC LIMIT K
)
#+end_src

*기술 스택*:

#+begin_src elisp
Backend: SQLite (Emacs 내장!)
  - sqlite-vss: 벡터 검색
  - FTS5: 키워드 검색

Embedding: Ollama (로컬)
  - nomic-embed-text (기본)

Reranker: 선택적 (외부 API)

Collections: 디렉토리별 관리
#+end_src

--------------

*** 2. *Org-roam Semantic Search* (lgmoneda) ⭐⭐⭐⭐
:PROPERTIES:
:CUSTOM_ID: org-roam-semantic-search-lgmoneda
:END:
*블로그*:
https://lgmoneda.github.io/2023/04/08/semantic-search-for-org-roam.html

*규모*: 3.4k notes (실전!)

*청킹 전략*:

#+begin_src python
# Node 단위 (Org-roam 노드 = Org heading)

1. Org-roam node 추출
   - node_text_nested_exclusive (자식 노드 제외)

2. 청크 분할 (너무 길면)
   - chunk_size: 300 characters
   - chunk_overlap: 0
   - Sentence-based split

3. Hierarchy 메타데이터 보존
   - [Parent > Child > Grandchild]
   - 각 청크에 hierarchy 추가
#+end_src

*Org structure 활용*:

#+begin_src python
# Properties 활용!
if ":SEARCH: ignore" in properties:
    skip_node()  # 검색 제외

# Hierarchy 보존
node_hierarchy = extract_org_hierarchy(node)
embedding_text = f"{hierarchy}\n\n{content}"
#+end_src

*핵심*: - Org *Node 단위* (Org heading = 의미 단위!) - *Hierarchy 보존*
(Parent > Child 관계) - *Properties 활용* (=:SEARCH: ignore=) - *300
characters* (짧게 청킹)

--------------

*** 3. *sem.el* (lepisma) ⭐⭐⭐⭐
:PROPERTIES:
:CUSTOM_ID: sem.el-lepisma
:END:
*블로그*: https://lepisma.xyz/2025/01/17/emacs-on-device-ml/

*컨셉*: 완전 로컬, Emacs 내장

*기술 스택*:

#+begin_src elisp
ML: ONNX.el (Emacs dynamic module)
  - all-MiniLM-L6-v2 (CPU 최적화)
  - 완전 온디바이스

Vector DB: LanceDB (로컬)

Indexing: IVF-PQ (빠른 검색)

테스트: 38,171 Emacs symbols 임베딩
#+end_src

*성능*:

#+begin_example
Initial search: ~0.089 sec/query
Indexed search: ~0.033 sec/query
#+end_example

*핵심*: - *완전 로컬*: 외부 프로세스 없음 - *Emacs 네이티브*: Dynamic
module - *빠름*: 0.033초 검색

--------------

*** 4. *ekg* (ahyatt) ⭐⭐⭐⭐
:PROPERTIES:
:CUSTOM_ID: ekg-ahyatt
:END:
*GitHub*: https://github.com/ahyatt/ekg

*컨셉*: Emacs Knowledge Graph

*기술*:

#+begin_src elisp
Backend: SQLite (triples DB)
  - Subject-Predicate-Object 구조

Org-mode: 기본 모드
  - ekg-embedding 모듈 (선택)
  - llm package 통합

Denote: ekg-denote.el (통합 개발 중)
#+end_src

*철학*: - *SQLite 기반* (파일시스템 아님) - *Triples* (지식 그래프) -
*Tag 중심* (Backlink보다) - *작은 원자적 노트*

*ekg vs Denote discussion*: - Denote: 파일 기반, Luhmann signature -
ekg: SQLite 기반, Tag + Graph - *ekg-denote.el*: 두 시스템 통합 (개발
중)

--------------

*** 5. *semext + embed-db* (ahyatt) ⭐⭐⭐
:PROPERTIES:
:CUSTOM_ID: semext-embed-db-ahyatt
:END:
*GitHub*: - https://github.com/ahyatt/semext - embed-db는 ekg-embedding
모듈에 통합된 것으로 보임

*컨셉*: Semantic versions of existing Emacs functionality

#+begin_src elisp
(use-package semext
  :vc (:fetcher github :repo "ahyatt/semext")
  :init
  (setopt semext-provider
    (make-llm-ollama :chat-model "gemma3:1b")))

;; M-x semext-search (의미 검색)
;; M-x semext-query-replace (의미 기반 교체)
#+end_src

--------------

*** 6. *emacs-rag-libsql* (John Kitchin) ⭐⭐⭐⭐⭐
:PROPERTIES:
:CUSTOM_ID: emacs-rag-libsql-john-kitchin
:END:
*GitHub*: https://github.com/jkitchin/emacs-rag-libsql

*규모*: YouTube 시연 (실전!)

*코드 실측* (Git Clone):

#+begin_src yaml
Total: ~920줄
  chunking.py: 66줄 (!)
  database.py: 854줄

청킹 로직 (단 40줄!):
  def chunk_text(text, chunk_size, overlap):
      chunks = []
      start = 0
      while start < len(text):
          end = min(start + chunk_size, len(text))
          chunk = text[start:end]
          line_number = text[:start].count('\n') + 1  # ← 핵심!
          chunks.append((chunk, line_number))
          start = max(start + 1, end - overlap)
      return chunks

  → Position 기반 (간단!)
  → Line number 추적 (Emacs goto-line)
#+end_src

*천재적 설계: Org Heading 별도 테이블*:

#+begin_src sql
-- 1. 문서 청크 테이블 (전체 내용)
CREATE TABLE documents (
    id TEXT PRIMARY KEY,          -- {path}:{chunk_index}
    source_path TEXT,
    chunk_index INTEGER,
    line_number INTEGER,          -- ← Emacs 통합!
    content TEXT,
    ...
);

CREATE TABLE embeddings (
    id TEXT PRIMARY KEY,
    vector BLOB,
    model TEXT
);

-- 2. Org Heading 테이블 (구조만!) ← 게임 체인저!
CREATE TABLE org_headings (
    id INTEGER PRIMARY KEY,
    source_path TEXT,
    line_number INTEGER,          -- ← 정확한 위치!
    heading_text TEXT,            -- * Heading
    tags TEXT,                    -- :tag1:tag2:
    level INTEGER,                -- *, **, ***
    ...
);

CREATE TABLE org_heading_embeddings (
    heading_id INTEGER,
    vector BLOB,
    model TEXT
);
#+end_src

*2-Tier 검색 전략*:

#+begin_src python
# Tier 1: Heading Search (빠름!)
query_org_headings_by_vector(query, n=20)
→ 100개 헤딩 검색
→ 30-50ms
→ 정확한 위치 (file:line)
→ Ivy 동적 검색 (타이핑하면서!)

# Tier 2: Content Search (느림, 필요 시만)
query_by_vector(query, n=5)
→ 20,000개 청크 검색
→ 200ms
→ 상세 내용

→ 평균 4배 빠름!
#+end_src

*gptel 통합* (Claude Code 에이전트):

#+begin_src elisp
(defvar emacs-rag-gptel-tool-search-headings
  (gptel-make-tool
   :function #'emacs-rag-gptel--search-headings
   :name "rag_search_headings"
   :description "Search org-mode headings semantically"
   :category "rag"))

;; Agent: "Find headings about Denote"
;; → rag_search_headings("Denote workflow")
;; → [[file:~/org/meta/denote.org::15][Denote silo]]
#+end_src

*기술 스택*:

#+begin_src yaml
Backend: LibSQL (SQLite fork) + Vector extension
API: FastAPI (8개 의존성, 경량)
Model: all-MiniLM-L6-v2 (384-dim, 80MB)
Reranker: cross-encoder/ms-marco-MiniLM-L-6-v2
Emacs: transient + Ivy + gptel
#+end_src

*핵심 통찰*:

#+begin_example
"Org Heading은 자연스러운 의미 단위"

Heading 별도 임베딩:
  → 빠른 구조 탐색
  → 정확한 위치
  → 에이전트 친화적

66줄 간단 청킹:
  → Position 기반 (충분히 좋음)
  → Line number 추적 (필수!)
#+end_example

--------------

** 📊 전문가 청킹 전략 비교표
:PROPERTIES:
:CUSTOM_ID: 전문가-청킹-전략-비교표
:END:
| 프로젝트           | 청킹 방식                             | 코드 라인 | 핵심 아이디어  | 한글 고려 |
|--------------------+---------------------------------------+-----------+----------------+-----------|
| *ELISA*            | forward-paragraph + semantic distance | ~30줄     | 의미 기반 병합 | ❌        |
| *Org-roam*         | Node 단위 (Org heading)               | 간단      | Hierarchy 보존 | ❌        |
| *sem.el*           | ONNX 내장                             | -         | 완전 로컬      | ❌        |
| *John Kitchin*     | Position 기반 + Heading 별도 테이블   | 66줄      | 2-Tier 검색    | ❌        |
| *embedding-config* | Org heading + 폴더별 차별화           | ~30줄     | 계층 구조      | ⚠️ 부분    |

*공통점*: - 30-66줄로 청킹 완료 (vs Chonkie 33,777줄) - Org 구조 활용
(Heading, Paragraph, Properties) - 간단함 > 복잡함

*한글 환경 문제*: - 모두 영어 환경 기준 - 한글 토큰 계산 미고려 - Denote
한글 제목 미지원 - filetags 한글/영어 혼재 미고려

--------------

** 🎯 Emacs 커뮤니티의 공통 패턴
:PROPERTIES:
:CUSTOM_ID: emacs-커뮤니티의-공통-패턴
:END:
*** Pattern 1: Org Structure 활용
:PROPERTIES:
:CUSTOM_ID: pattern-1-org-structure-활용
:END:
*Org 고유 구조*:

#+begin_src org
,* Heading 1                    ← 자연스러운 청킹 단위!
  :PROPERTIES:
  :ID: unique-id
  :FILETAGS: :emacs:org:       ← 메타데이터
  :END:

,** Subheading                  ← 계층 (Level 2)
   Content...

[[id:unique-id][Link]]         ← 연결
#+end_src

*활용 방식*:

#+begin_example
ELISA: forward-paragraph (Emacs 내장)
Org-roam: Node 단위 (Org heading)
John Kitchin: Heading 별도 테이블 + 정규식
embedding-config: Org heading 기준 (*, **, ***)

→ Org structure가 이미 청킹을 위해 설계됨!
#+end_example

--------------

*** Pattern 2: 간단한 청킹 로직 (30-66줄)
:PROPERTIES:
:CUSTOM_ID: pattern-2-간단한-청킹-로직-30-66줄
:END:
| 프로젝트 | 청킹 방식                             | 코드 복잡도 |
|----------+---------------------------------------+-------------|
| ELISA    | forward-paragraph + semantic distance | ~30줄       |
| Org-roam | Node 단위 + 300 char split            | 간단        |
| sem.el   | (미확인, ONNX 내장 가능성)            | -           |
| ekg      | SQLite 기반                           | Triples     |

*공통점*: - *Emacs 내장 함수 활용* (forward-paragraph,
forward-sentence) - *간단한 로직* (복잡한 알고리즘 회피) - *Org 구조
존중* (Heading, Node, Paragraph)

--------------

*** Pattern 3: SQLite 백엔드
:PROPERTIES:
:CUSTOM_ID: pattern-3-sqlite-백엔드
:END:
#+begin_src elisp
# ELISA: sqlite-vss + FTS5
# ekg: triples (Subject-Predicate-Object)
# sem.el: LanceDB (선택적)

→ Emacs 29.2+ 내장 SQLite 활용!
#+end_src

--------------

*** Pattern 4: Hybrid Search
:PROPERTIES:
:CUSTOM_ID: pattern-4-hybrid-search
:END:
#+begin_example
Vector Search (의미)
    +
Keyword Search (BM25/FTS5)
    +
Reranker (선택적)

→ 품질 > 복잡도
#+end_example

--------------

*** Pattern 5: 로컬 우선
:PROPERTIES:
:CUSTOM_ID: pattern-5-로컬-우선
:END:
#+begin_src elisp
# ELISA: Ollama (nomic-embed-text)
# sem.el: ONNX (all-MiniLM-L6-v2, CPU)
# ekg: llm package (다양한 provider)
# Org-roam: OpenAI or sentence-transformers

→ 프라이버시, 통제권
#+end_src

--------------

** 💡 왜 Chonkie 같은 복잡한 라이브러리가 존재하나?
:PROPERTIES:
:CUSTOM_ID: 왜-chonkie-같은-복잡한-라이브러리가-존재하나
:END:
*** 타겟 사용자 차이
:PROPERTIES:
:CUSTOM_ID: 타겟-사용자-차이
:END:
*Chonkie 타겟*:

#+begin_example
범용 RAG 시스템
- 다양한 문서 (PDF, Code, Markdown, HTML...)
- 다양한 도메인 (법률, 의료, 기술...)
- 다양한 사용자 (초보자 ~ 전문가)

→ 모든 경우를 커버하려다 보니 복잡
→ 33,777줄 코드
#+end_example

*Emacs 커뮤니티 타겟*:

#+begin_example
Org-mode 지식베이스
- 단일 포맷 (Org-mode)
- 특정 도메인 (개인 지식)
- 전문가 사용자 (Org-mode 이해)

→ Org structure 활용으로 단순화 가능
→ ~30줄 코드면 충분
#+end_example

--------------

** 🏗️ Org-mode의 구조적 장점
:PROPERTIES:
:CUSTOM_ID: org-mode의-구조적-장점
:END:
*** "Org-mode는 이미 청킹을 위해 설계되었다"
:PROPERTIES:
:CUSTOM_ID: org-mode는-이미-청킹을-위해-설계되었다
:END:
*Org Heading Hierarchy*:

#+begin_src org
,* Level 1 (개념)
,** Level 2 (세부 개념)
,*** Level 3 (구체적 내용)
#+end_src

*→ 자연스러운 청킹 단위!*

*Paragraph*:

#+begin_src org
첫 번째 문단.
여러 줄에 걸쳐 작성.

두 번째 문단.
(빈 줄로 구분)
#+end_src

*→ forward-paragraph로 청킹!*

*Properties*:

#+begin_src org
:PROPERTIES:
:ID: unique-id
:CUSTOM_TAG: value
:SEARCH: ignore  ← 검색 제외!
:END:
#+end_src

*→ 메타데이터 + 제어!*

*Denote Filename*:

#+begin_example
20241213T161527--한글-제목__영어_태그들.org
#+end_example

*→ 파싱 가능, 메타데이터 풍부!*

--------------

** 📐 memex-kb를 위한 지혜
:PROPERTIES:
:CUSTOM_ID: memex-kb를-위한-지혜
:END:
*** 1. Org Structure 활용 청킹
:PROPERTIES:
:CUSTOM_ID: org-structure-활용-청킹
:END:
*embedding-config 전략 (검증됨)*:

#+begin_src python
# Org heading 기준 청킹
sections = re.split(r'\n\*+\s+', text)  # *, **, ***

→ 30줄로 충분!
→ Org 구조 존중
→ 의미 단위 보존
#+end_src

*Chonkie 필요 없음*:

#+begin_example
Chonkie RecursiveChunker: 379줄
embedding-config: 30줄

→ 12배 간단
→ 동일한 목적
→ Org에 특화
#+end_example

--------------

*** 2. Hybrid Search (ELISA 방식)
:PROPERTIES:
:CUSTOM_ID: hybrid-search-elisa-방식
:END:
*Vector + FTS* (SQLite로!):

#+begin_src sql
-- ELISA 패턴 (검증됨)

Vector Search (sqlite-vss)
    +
Full Text Search (FTS5)
    +
Reciprocal Rank Fusion (SQL!)

→ 모든 것이 SQLite 안에서!
#+end_src

*memex-kb v2.0 적용*:

#+begin_src python
# Supabase도 PostgreSQL = SQL 가능!

CREATE OR REPLACE FUNCTION hybrid_search(
  query_text TEXT,
  query_embedding vector(1024),
  match_count INT
)
RETURNS TABLE(...) AS $$
  WITH
  vector_results AS (
    SELECT * FROM match_org_garden_documents(...)
  ),
  fts_results AS (
    SELECT * FROM org_garden_documents
    WHERE to_tsvector('korean', content) @@ plainto_tsquery('korean', query_text)
  ),
  combined AS (
    -- Reciprocal Rank Fusion
    SELECT ..., RRF_score
    FROM vector_results FULL OUTER JOIN fts_results
  )
  SELECT * FROM combined ORDER BY RRF_score LIMIT match_count;
$$;
#+end_src

--------------

*** 3. Properties 활용 (Org-roam 방식)
:PROPERTIES:
:CUSTOM_ID: properties-활용-org-roam-방식
:END:
*검색 제어*:

#+begin_src org
,* Important Note
  :PROPERTIES:
  :SEARCH: include  ← 검색 우선
  :PRIORITY: high
  :END:

,* Temporary Draft
  :PROPERTIES:
  :SEARCH: ignore  ← 검색 제외
  :END:
#+end_src

*memex-kb v2.0 적용*:

#+begin_src python
# Frontmatter로 변환
def parse_org_properties(content):
    if ":SEARCH: ignore" in content:
        return None  # 스킵

    priority = extract_property("PRIORITY")
    if priority == "high":
        boost_weight = 1.5  # 가중치
#+end_src

--------------

*** 4. 로컬 우선 (sem.el 방식)
:PROPERTIES:
:CUSTOM_ID: 로컬-우선-sem.el-방식
:END:
*완전 온디바이스*:

#+begin_src elisp
;; sem.el
ONNX.el (Emacs dynamic module)
    +
all-MiniLM-L6-v2 (80MB, CPU)
    +
LanceDB (로컬 벡터 DB)

→ 외부 의존 0
→ 프라이버시 100%
→ 0.033초 검색
#+end_src

*memex-kb v2.0*:

#+begin_src python
# Ollama (로컬) + Supabase (로컬 or 클라우드)
# 선택권 제공!

Local: Ollama + FAISS
Cloud: Ollama + Supabase
Hybrid: Ollama + Qdrant (self-hosted)
#+end_src

--------------

** 🎓 Emacs 커뮤니티의 철학
:PROPERTIES:
:CUSTOM_ID: emacs-커뮤니티의-철학
:END:
*** "간단함은 궁극의 정교함" (Leonardo da Vinci)
:PROPERTIES:
:CUSTOM_ID: 간단함은-궁극의-정교함-leonardo-da-vinci
:END:
*Chonkie*: 33,777줄 - Recipe 시스템 - C extensions - 다양한 Chunker
(9개) - 복잡한 설정

*vs*

*ELISA*: ~30줄 청킹 - forward-paragraph - Cosine distance - Threshold
병합 - 간단한 로직

*→ 2,945개 파일 임베딩 성공한 방식도 ~30줄!*

--------------

*** "Org-mode는 이미 설계되었다"
:PROPERTIES:
:CUSTOM_ID: org-mode는-이미-설계되었다
:END:
*Org 구조*:

#+begin_src org
,* Heading (자연스러운 청킹 단위)
  :PROPERTIES: (메타데이터)
  :END:

  Paragraph (의미 단위)

  - List (구조화)

,** Subheading (계층)
#+end_src

*→ 청킹을 위해 재설계할 필요 없음!*

--------------

*** "통제권 > 편리함"
:PROPERTIES:
:CUSTOM_ID: 통제권-편리함
:END:
*Chonkie*: - 블랙박스 (379줄 RecursiveChunker) - 학습 필요
(RecursiveRules, recipe) - 디버깅 어려움

*ELISA/embedding-config*: - 투명함 (30줄, 읽기 쉬움) - 학습 불필요
(forward-paragraph 직관적) - 디버깅 쉬움 (직접 작성 코드)

*→ 자유 소프트웨어 철학: 코드는 읽을 수 있어야 한다*

--------------

** 📊 실전 검증 데이터
:PROPERTIES:
:CUSTOM_ID: 실전-검증-데이터
:END:
*** ELISA 사용 사례
:PROPERTIES:
:CUSTOM_ID: elisa-사용-사례
:END:
#+begin_example
Collections:
  - builtin manuals (Emacs 매뉴얼)
  - external manuals (패키지 문서)
  - 로컬 파일 (디렉토리)
  - Web search (DuckDuckGo/SearXNG)

Hybrid Search:
  - Vector (sqlite-vss)
  - FTS (BM25)
  - Reranker (선택적)

Performance:
  - 비동기 처리 (async.el)
  - 배치 임베딩 (300개씩)
#+end_example

--------------

*** Org-roam 사용 사례
:PROPERTIES:
:CUSTOM_ID: org-roam-사용-사례
:END:
#+begin_example
Notes: 3.4k (실전 규모!)

Chunking:
  - Node 단위 (Org heading)
  - 300 characters (짧게)
  - Hierarchy 보존

Metadata:
  - :SEARCH: ignore (제외)
  - Node ID, Title, Hierarchy

Model:
  - OpenAI ada-002 (원래)
  - sentence-transformers (대안)
#+end_example

--------------

*** embedding-config 사용 사례 (memex-kb 참고)
:PROPERTIES:
:CUSTOM_ID: embedding-config-사용-사례-memex-kb-참고
:END:
#+begin_example
Files: 2,945 Org → 8,310 chunks

Chunking:
  - Org heading 기준 (*, **, ***)
  - 폴더별 차별화:
    - meta: 1500 tokens
    - bib: 1200 tokens
    - journal: 800 tokens
    - notes: 1000 tokens

Performance:
  - 100% 완료 (15분)
  - GPU-03 (Ollama)
  - Supabase pgvector
#+end_example

--------------

** 🏆 memex-kb v2.0 전략 확정
:PROPERTIES:
:CUSTOM_ID: memex-kb-v2.0-전략-확정
:END:
*** Emacs 커뮤니티 지혜 적용
:PROPERTIES:
:CUSTOM_ID: emacs-커뮤니티-지혜-적용
:END:
*1. 간단한 청킹* (ELISA 패턴):

#+begin_src python
# embedding-config 30줄 그대로 사용
# Org heading 기준 (*) = forward-paragraph 패턴

def chunk_text(text, max_size, overlap):
    sections = re.split(r'\n\*+\s+', text)  # Org heading
    # ... 30줄 로직
#+end_src

*2. Hybrid Search* (ELISA SQL 패턴):

#+begin_src sql
-- Supabase에서 동일하게 구현
-- Vector + FTS + RRF
#+end_src

*3. Properties 활용* (Org-roam 패턴):

#+begin_src python
# Frontmatter로 변환
if frontmatter.get('search') == 'ignore':
    skip()

priority = frontmatter.get('priority', 'normal')
boost = {'high': 1.5, 'normal': 1.0, 'low': 0.8}[priority]
#+end_src

*4. 폴더별 차별화* (embedding-config 검증):

#+begin_src python
FOLDER_CONFIG = {
    'architecture': {'chunk_size': 1500, 'overlap': 200},
    # ...
}
#+end_src

*5. SQLite or PostgreSQL* (Backend):

#+begin_src python
# Local: SQLite (ELISA 패턴, Emacs 내장)
# Production: Supabase PostgreSQL (검증됨)
#+end_src

--------------

** 📝 핵심 깨달음
:PROPERTIES:
:CUSTOM_ID: 핵심-깨달음
:END:
*** Q: 왜 복잡한 Chonkie가 존재하나?
:PROPERTIES:
:CUSTOM_ID: q-왜-복잡한-chonkie가-존재하나
:END:
*A*: 범용성을 추구하다 보니 복잡해짐

#+begin_example
Chonkie:
  모든 문서 타입 (PDF, Code, Markdown, HTML...)
  모든 청킹 방식 (9가지)
  모든 사용자 (초보자 ~ 전문가)

  → 33,777줄
#+end_example

--------------

*** Q: Org-mode는?
:PROPERTIES:
:CUSTOM_ID: q-org-mode는
:END:
*A*: Org 구조가 이미 청킹을 위해 설계됨

#+begin_example
Org Heading:
  ,* = Level 1 (개념)
  ,** = Level 2 (세부)
  ,*** = Level 3 (구체)

Paragraph:
  빈 줄로 구분 = forward-paragraph

Properties:
  :SEARCH: ignore = 제어
  :ID: uuid = 연결

Denote:
  timestamp--title__tags = 메타데이터

→ 30줄이면 충분
→ Org 철학 존중
→ 간단함 > 복잡함
#+end_example

--------------

*** Q: Emacs 커뮤니티의 접근?
:PROPERTIES:
:CUSTOM_ID: q-emacs-커뮤니티의-접근
:END:
*A*: 철학적, 실용적, 간단함

#+begin_example
1. Org Structure 활용
   → 재설계 아닌 활용

2. Emacs 내장 함수
   → forward-paragraph, forward-sentence

3. SQLite 백엔드
   → Emacs 29.2+ 내장

4. Hybrid Search
   → Vector + FTS + RRF

5. 로컬 우선
   → Ollama, ONNX

6. 간단한 코드
   → 30줄로 충분
   → 읽을 수 있어야 함
   → 통제 가능해야 함
#+end_example

--------------

** 🎯 memex-kb v2.0 최종 전략
:PROPERTIES:
:CUSTOM_ID: memex-kb-v2.0-최종-전략
:END:
*** Emacs 지혜 통합
:PROPERTIES:
:CUSTOM_ID: emacs-지혜-통합
:END:
#+begin_src python
┌─────────────────────────────────────────────┐
│ Conversion (v1.x)                           │
│ - Backend Adapter (Google Docs, Dooray...) │
│ - Denote 파일명 생성                        │
│ - 규칙 기반 분류                            │
└─────────────────────────────────────────────┘
                ↓
┌─────────────────────────────────────────────┐
│ Embedding (v2.0) - Emacs 지혜 적용         │
│                                             │
│ 1. 청킹 (ELISA 패턴):                       │
│    - Markdown Heading 기준 (#, ##, ###)    │
│    - 30줄 간단 로직                         │
│    - 폴더별 차별화 (검증됨)                 │
│                                             │
│ 2. 메타데이터 (Org-roam 패턴):              │
│    - Denote 파일명 파싱                     │
│    - Frontmatter Properties                 │
│    - search: ignore 지원                    │
│                                             │
│ 3. 임베딩 (sem.el 패턴):                    │
│    - Ollama 로컬 (mxbai-embed-large)       │
│    - 완전 통제                              │
│                                             │
│ 4. 저장 (ekg 패턴):                         │
│    - PostgreSQL (Supabase or 로컬)         │
│    - 또는 SQLite (Emacs 통합용)            │
└─────────────────────────────────────────────┘
                ↓
┌─────────────────────────────────────────────┐
│ Search (ELISA 패턴)                         │
│ - Hybrid: Vector + FTS + RRF (SQL!)        │
│ - Reranker (선택적)                         │
└─────────────────────────────────────────────┘
                ↓
┌─────────────────────────────────────────────┐
│ Emacs Integration (semext 스타일)           │
│ - M-x memex-kb-search                       │
│ - Denote 링크 삽입                          │
└─────────────────────────────────────────────┘
#+end_src

--------------

** 🌟 차별화 포인트
:PROPERTIES:
:CUSTOM_ID: 차별화-포인트
:END:
*** memex-kb = "Emacs 철학 + 범용성"
:PROPERTIES:
:CUSTOM_ID: memex-kb-emacs-철학-범용성
:END:
*Emacs 프로젝트들*:

#+begin_example
ELISA: Emacs 전용 (Info, local files)
Org-roam: Org-roam 전용
sem.el: Emacs symbols
ekg: SQLite 기반

→ Emacs 내부용
#+end_example

*memex-kb*:

#+begin_example
변환: Google Docs, Dooray, Confluence...
  ↓ Denote Markdown (Org 철학 적용!)
임베딩: Emacs 커뮤니티 전략 (30줄 청킹)
  ↓ Vector DB
검색: ELISA Hybrid Search 패턴
  ↓ Emacs/n8n/API

→ Legacy → Emacs 철학으로 변환하는 입구!
#+end_example

*독창성*:

#+begin_example
1. Emacs 외부 소스 (Google Docs, Dooray...)
2. Emacs 철학 적용 (Denote, 간단 청킹)
3. Emacs 통합 가능 (semext 스타일)
4. 범용 플랫폼 가능 (n8n, API)

→ "Emacs 안팎을 연결하는 다리"
#+end_example

--------------

** 🔗 참고 프로젝트
:PROPERTIES:
:CUSTOM_ID: 참고-프로젝트
:END:
*Emacs RAG*: - ELISA: https://github.com/s-kostyaev/elisa (~30줄 청킹,
SQLite, Hybrid Search) - sem.el:
https://lepisma.xyz/2025/01/17/emacs-on-device-ml/ (ONNX, 로컬) - ekg:
https://github.com/ahyatt/ekg (Knowledge Graph, SQLite) - semext:
https://github.com/ahyatt/semext (Semantic Emacs)

*Org 특화*: - Org-roam semantic:
https://lgmoneda.github.io/2023/04/08/semantic-search-for-org-roam.html
(3.4k notes) - ekg-denote: ekg + Denote 통합 (개발 중)

*참고*: - ahyatt (Andrew Hyatt): ekg, semext, llm, triples 개발자 -
Protesilaos Stavrou: Denote 개발자

--------------

** 💡 결론: "Org-mode 철학을 따르라"
:PROPERTIES:
:CUSTOM_ID: 결론-org-mode-철학을-따르라
:END:
*** Emacs 커뮤니티의 지혜
:PROPERTIES:
:CUSTOM_ID: emacs-커뮤니티의-지혜
:END:
#+begin_example
1. 간단함 > 복잡함
   - 30줄 청킹 > 379줄 라이브러리

2. Org 구조 활용 > 재발명
   - Heading, Paragraph, Properties

3. 통제권 > 편리함
   - 직접 작성 > 블랙박스

4. 로컬 우선 > 클라우드
   - Ollama, ONNX > API

5. SQLite/PostgreSQL > 파일
   - 검색 최적화

6. Hybrid Search > Vector만
   - Vector + FTS + RRF
#+end_example

--------------

*** memex-kb의 포지션
:PROPERTIES:
:CUSTOM_ID: memex-kb의-포지션
:END:
#+begin_example
"Emacs 철학을 Legacy 세계에 전파한다"

Legacy 문서 (복잡, 불일치)
    ↓ memex-kb (Denote 규칙)
Org 철학 (간단, 일관)
    ↓ Emacs 커뮤니티 전략
RAG-ready (품질, 통제)
#+end_example

*가치*:

#+begin_example
Chonkie: 범용 RAG (복잡)
ELISA: Emacs 내부용 (간단)
memex-kb: 둘을 연결 (Emacs 철학 + 범용성)

→ 독창적 포지셔닝!
#+end_example

--------------

--------------

** 🌏 한글 환경 특화 전략
:PROPERTIES:
:CUSTOM_ID: 한글-환경-특화-전략
:END:
*** 전문가 방식의 한글 적용 문제점
:PROPERTIES:
:CUSTOM_ID: 전문가-방식의-한글-적용-문제점
:END:
*ELISA/John Kitchin/Org-roam (영어 환경)*:

#+begin_src org
,* Machine Learning Concepts      ← 영어 헤딩
  :PROPERTIES:
  :FILETAGS: :ml:ai:deeplearning: ← 영어 태그
  :END:

파일명: 20250101T120000.org          ← timestamp만
태그: :ml:ai:                        ← 영어만
#+end_src

*embedding-config/Denote (한글 환경)*:

#+begin_src org
,* 머신러닝 개념 정리                 ← 한글 헤딩!
  :PROPERTIES:
  :FILETAGS: :ml:ai:머신러닝:개념:   ← 한글/영어 혼재!
  :END:

파일명: 20250101T120000--머신러닝-개념-정리__ml_ai_machinelearning.org
        └────timestamp────┘ └──한글 제목──┘ └────영어 태그────┘
              ↑                  ↑                 ↑
          Denote ID          인간 친화적        검색용
#+end_src

--------------

*** 한글 환경 고유 이슈
:PROPERTIES:
:CUSTOM_ID: 한글-환경-고유-이슈
:END:
*1. 토큰 계산*:

#+begin_src python
# 영어 (John Kitchin/ELISA)
"machine learning" = 2 tokens
chars_per_token = 4-5 (평균)

# 한글 (embedding-config 검증)
"머신러닝" = 2 tokens
chars_per_token = 1.5-2 (한글은 더 조밀!)

→ 동일 chunk_size라도 한글이 더 많은 정보 포함
→ 한글 특화 조정 필요
#+end_src

*2. Denote 파일명 파싱*:

#+begin_src python
# 영어 전문가들 (Denote 미지원)
filename: "20250101T120000.org"
→ timestamp만 추출

# Denote (한글 제목!)
filename: "20250101T120000--머신러닝-개념__ml_ai.org"

파싱 필요:
  - timestamp: 20250101T120000
  - korean_title: "머신러닝-개념"
  - english_tags: ["ml", "ai"]

→ embedding-config에 이미 구현됨!
#+end_src

*3. FILETAGS 혼재*:

#+begin_src org
,#+filetags: :emacs:org:이맥스:조직모드:

영어: emacs, org
한글: 이맥스, 조직모드

→ 둘 다 임베딩에 포함해야 검색 품질 향상
#+end_src

*4. Heading 한글/영어 혼재*:

#+begin_src org
,* Emacs 설정 가이드           ← 혼재
,** org-mode 커스터마이징      ← 혼재
,*** 한글 폰트 설정            ← 한글
,**** Font Configuration       ← 영어

→ 모든 레벨에서 혼재 가능
→ 정규식은 동일하게 작동 (문제 없음)
→ 하지만 임베딩 모델은 한글 지원 필수!
#+end_src

--------------

*** 한글 특화 해결책
:PROPERTIES:
:CUSTOM_ID: 한글-특화-해결책
:END:
*1. 임베딩 모델 선택* (중요!):

#+begin_src yaml
영어 모델 (John Kitchin 기본):
  all-MiniLM-L6-v2:
    dimension: 384
    한글 지원: ⭐⭐ (제한적)

한글 최적화 (embedding-config 검증):
  multilingual-e5-large:
    dimension: 1024
    한글 지원: ⭐⭐⭐⭐
    검증: 2,945개 Org 파일 성공

  mxbai-embed-large:
    dimension: 1024
    한글 지원: ⭐⭐⭐⭐⭐
    속도: multilingual-e5보다 빠름

→ John Kitchin 전략에 한글 모델만 교체!
#+end_src

*2. Denote 파싱* (embedding-config 재사용):

#+begin_src python
# embedding-config에서 검증됨 (process_org_garden.py)

def parse_denote_filename(filepath):
    """
    20250101T120000--머신러닝-개념__ml_ai.org
    """
    pattern = r'(\d{8}T\d{6})--(.+?)__(.+?)\.org'
    match = re.match(pattern, filename)

    identifier = match.group(1)    # 20250101T120000
    korean_title = match.group(2)  # 머신러닝-개념
    english_tags = match.group(3).split('_')  # ['ml', 'ai']

    return {
        'identifier': identifier,
        'korean_title': korean_title,
        'denote_tags': english_tags
    }

→ 이미 완벽하게 구현됨!
→ 그대로 재사용!
#+end_src

*3. 한글/영어 태그 통합*:

#+begin_src python
# FILETAGS 파싱
def parse_filetags(content):
    """
    ,#+filetags: :emacs:org:이맥스:조직모드:
    """
    pattern = r'#\+filetags:\s*:(.+?):'
    match = re.search(pattern, content, re.IGNORECASE)

    if match:
        all_tags = match.group(1).split(':')
        korean_tags = [t for t in all_tags if re.search(r'[가-힣]', t)]
        english_tags = [t for t in all_tags if re.match(r'^[a-zA-Z]+$', t)]

        return {
            'korean_tags': korean_tags,      # ['이맥스', '조직모드']
            'english_tags': english_tags,    # ['emacs', 'org']
            'all_tags': all_tags
        }

# 임베딩 텍스트 생성 (John Kitchin 패턴 + 한글)
def prepare_heading_embedding(heading_text, denote_meta, filetags):
    """
    John Kitchin: heading + :tag1:tag2:
    한글 특화: heading + denote_tags + filetags (한글+영어)
    """
    parts = [heading_text]

    # Denote 태그 (영어)
    if denote_meta['denote_tags']:
        parts.append(' '.join(denote_meta['denote_tags']))

    # FILETAGS (한글+영어)
    if filetags['all_tags']:
        parts.append(' '.join(filetags['all_tags']))

    return ' '.join(parts)

# 예시
heading_text = "머신러닝 개념 정리"
denote_tags = ["ml", "ai"]
filetags = ["emacs", "org", "이맥스", "조직모드"]

result = "머신러닝 개념 정리 ml ai emacs org 이맥스 조직모드"

→ 한글 임베딩 모델이 모두 이해!
#+end_src

*4. 한글 토큰 계산*:

#+begin_src python
# embedding-config 검증된 방식

def calculate_korean_tokens(text):
    """
    한글: 3자 = 1토큰
    영어: 4자 = 1토큰
    """
    korean_chars = len(re.findall(r'[가-힣]', text))
    english_chars = len(re.findall(r'[a-zA-Z]', text))
    other_chars = len(text) - korean_chars - english_chars

    tokens = (korean_chars / 3) + (english_chars / 4) + (other_chars / 3)
    return int(tokens)

# John Kitchin 방식 개선
def chunk_text_korean(text, chunk_size=800, overlap=100):
    """
    Position 기반 (John Kitchin)
    + 한글 토큰 계산 (embedding-config)
    """
    chunks = []
    start = 0

    while start < len(text):
        # 한글 토큰 기준으로 end 계산
        current_tokens = 0
        end = start

        while end < len(text) and current_tokens < chunk_size:
            char = text[end]
            if re.match(r'[가-힣]', char):
                current_tokens += 1/3  # 3자 = 1토큰
            elif re.match(r'[a-zA-Z]', char):
                current_tokens += 1/4  # 4자 = 1토큰
            else:
                current_tokens += 1/3
            end += 1

        chunk = text[start:end]
        line_number = text[:start].count('\n') + 1

        chunks.append((chunk, line_number))
        start = max(start + 1, end - overlap)

    return chunks

→ John Kitchin 간단함 + embedding-config 한글 계산
#+end_src

--------------

*** Pattern 2: 간단한 청킹 로직 (30-66줄)
:PROPERTIES:
:CUSTOM_ID: pattern-2-간단한-청킹-로직-30-66줄-1
:END:

--------------

** 🚀 ~/org/ 실험 계획: "전문가 따라하기 + 한글 특화"
:PROPERTIES:
:CUSTOM_ID: org-실험-계획-전문가-따라하기-한글-특화
:END:
*** Phase 1: John Kitchin 패턴 (1주) ⭐⭐⭐⭐⭐
:PROPERTIES:
:CUSTOM_ID: phase-1-john-kitchin-패턴-1주
:END:
*목표*: Org Heading 별도 테이블 + 2-Tier 검색

*선택 이유*:

#+begin_example
✅ 간단함: 66줄 청킹 + 80줄 헤딩 파싱
✅ 실용적: 2-Tier 검색 (빠름 + 정확)
✅ 검증됨: YouTube 시연
✅ gptel 통합: Claude Code 에이전트
✅ 한글 호환: 정규식은 한글 문제 없음
#+end_example

*한글 수정사항*:

#+begin_src python
# 1. 임베딩 모델 교체
all-MiniLM-L6-v2 (384-dim, 영어)
    ↓
mxbai-embed-large (1024-dim, 한글 최적화)

# 2. Denote 파싱 추가 (embedding-config 재사용)
def parse_denote_filename(filepath): ...

# 3. FILETAGS 한글/영어 통합
def parse_filetags(content): ...
def prepare_heading_embedding(heading, denote, filetags): ...

# 4. 한글 토큰 계산 (선택적)
# 일단 John Kitchin position 기반 그대로 사용
# 필요 시 embedding-config 한글 계산 추가
#+end_src

*실험 체크리스트*:

#+begin_src sh
Day 1-2: 설치 & 설정
  - [ ] emacs-rag-libsql 설치 (uv sync)
  - [ ] 한글 모델 교체 (mxbai-embed-large)
  - [ ] Emacs 설정 (~/.doom.d/config.el)

Day 3-4: 소규모 테스트
  - [ ] ~/org/notes/ 100개 파일 인덱싱
  - [ ] Heading 검색 테스트
  - [ ] 한글 쿼리 테스트:
    - "머신러닝" vs "machine learning"
    - "이맥스" vs "emacs"
    - 혼재: "Emacs 설정"

Day 5-7: 검증 & 한글 이슈 파악
  - [ ] 한글 검색 품질 측정
  - [ ] Denote 파싱 필요성 확인
  - [ ] FILETAGS 혼재 문제 확인
  - [ ] gptel 통합 테스트
#+end_src

--------------

*** Phase 2: embedding-config 통합 (1주)
:PROPERTIES:
:CUSTOM_ID: phase-2-embedding-config-통합-1주
:END:
*목표*: 폴더별 차별화 + 지식 계층

*통합 코드*:

#+begin_src python
# John Kitchin 기본 구조
org_headings 테이블
documents 테이블

# embedding-config 폴더별 설정 추가
FOLDER_CONFIG = {
    'meta': {'chunk_size': 1500, 'overlap': 200},
    'bib': {'chunk_size': 1200, 'overlap': 150},
    'journal': {'chunk_size': 800, 'overlap': 100},
    'notes': {'chunk_size': 1000, 'overlap': 150}
}

# emacs-rag-server 수정
def index_file(path, content):
    folder = get_folder_from_path(path)  # ~/org/meta/ → "meta"
    config = FOLDER_CONFIG.get(folder, DEFAULT)

    # 폴더별 청킹
    chunks = chunk_text(content,
                        chunk_size=config['chunk_size'],
                        overlap=config['overlap'])
#+end_src

*실험*:

#+begin_src sh
Day 1-3: 폴더별 인덱싱
  - [ ] ~/org/meta/ (530개)
  - [ ] ~/org/bib/ (646개)
  - [ ] ~/org/journal/ (691개)
  - [ ] ~/org/notes/ (770개)

Day 4-5: 청크 크기 검증
  - [ ] SELECT folder, AVG(chunk_size) FROM documents GROUP BY folder
  - [ ] meta 청크가 더 큰지 확인
  - [ ] 검색 품질 폴더별 비교

Day 6-7: 성능 측정
  - [ ] MRR@10, Recall@5, Recall@10
  - [ ] embedding-config 결과와 비교 (MRR 0.85)
#+end_src

--------------

*** Phase 3: ELISA Hybrid Search (1주)
:PROPERTIES:
:CUSTOM_ID: phase-3-elisa-hybrid-search-1주
:END:
*목표*: Vector + FTS + RRF

*LibSQL SQL 구현* (ELISA 패턴):

#+begin_src sql
-- ELISA RRF 패턴을 LibSQL에 적용

WITH
vector_search AS (
  SELECT id, vector_distance_cosine(vector, ?) as distance,
         ROW_NUMBER() OVER (ORDER BY distance) as rank
  FROM embeddings
  ORDER BY distance LIMIT 50
),
fts_search AS (
  SELECT id, bm25(documents_fts) as score,
         ROW_NUMBER() OVER (ORDER BY score DESC) as rank
  FROM documents_fts
  WHERE MATCH ?
  LIMIT 50
),
heading_search AS (
  SELECT heading_id as id, vector_distance_cosine(vector, ?) as distance,
         ROW_NUMBER() OVER (ORDER BY distance) as rank
  FROM org_heading_embeddings
  LIMIT 50
),
rrf_combined AS (
  SELECT
    COALESCE(v.id, f.id, h.id) AS id,
    (COALESCE(1.0/(60 + v.rank), 0.0) +
     COALESCE(1.0/(60 + f.rank), 0.0) +
     COALESCE(1.0/(60 + h.rank), 0.0)) AS score
  FROM vector_search v
  FULL OUTER JOIN fts_search f USING (id)
  FULL OUTER JOIN heading_search h USING (id)
  ORDER BY score DESC
  LIMIT 20
)
SELECT * FROM rrf_combined;
#+end_src

*실험*:

#+begin_src sh
Day 1-3: RRF SQL 함수 작성
  - [ ] emacs-rag-server 수정
  - [ ] /search/hybrid 엔드포인트 추가
  - [ ] RRF 알고리즘 구현

Day 4-5: 품질 비교
  - [ ] Vector only vs Hybrid 비교
  - [ ] MRR 향상도 측정
  - [ ] 한글 쿼리 정확도

Day 6-7: gptel 통합
  - [ ] rag_search_hybrid 도구 추가
  - [ ] Claude Code 에이전트 테스트
#+end_src

--------------

** 🎯 통합 전략: "세 가지 지혜 + 한글 특화"
:PROPERTIES:
:CUSTOM_ID: 통합-전략-세-가지-지혜-한글-특화
:END:
*** 최종 설계
:PROPERTIES:
:CUSTOM_ID: 최종-설계
:END:
#+begin_src yaml
기본 프레임워크: John Kitchin (emacs-rag-libsql)
  청킹: 66줄 position 기반
  구조: Org Heading 별도 테이블
  검색: 2-Tier (헤딩 → 내용)
  통합: gptel 도구

한글 특화: embedding-config (검증됨)
  모델: mxbai-embed-large (1024-dim)
  파싱: Denote 한글 제목 + 영어 태그
  태그: FILETAGS 한글/영어 통합
  토큰: 한글 3자 = 1토큰

폴더별 차별화: embedding-config (검증됨)
  meta: 1500 토큰 (개념 전체 맥락)
  bib: 1200 토큰 (인용 포함)
  journal: 800 토큰 (일일 단위)
  notes: 1000 토큰 (균형)

Hybrid Search: ELISA (검증됨)
  Vector + FTS + RRF (SQL로!)
  SQLite or PostgreSQL

에이전트: John Kitchin (검증됨)
  gptel 도구 (rag_search, rag_search_headings)
  transient menu
  Ivy 동적 검색
#+end_src

--------------

** 📋 3주 실험 타임라인
:PROPERTIES:
:CUSTOM_ID: 주-실험-타임라인
:END:
*** Week 1: John Kitchin 기본 (~/org/notes/ 소규모)
:PROPERTIES:
:CUSTOM_ID: week-1-john-kitchin-기본-orgnotes-소규모
:END:
#+begin_example
Mon-Tue: emacs-rag-libsql 설치, 한글 모델 교체
Wed-Thu: 100개 파일 인덱싱, 검색 테스트
Fri-Sun: 한글 이슈 파악, 개선 필요사항 정리

목표: John Kitchin 전략 이해 + 한글 문제점 발견
#+end_example

*** Week 2: 한글 특화 (~/org/ 전체)
:PROPERTIES:
:CUSTOM_ID: week-2-한글-특화-org-전체
:END:
#+begin_example
Mon-Tue: Denote 파싱 추가 (embedding-config 재사용)
Wed: FILETAGS 한글/영어 통합
Thu-Fri: 폴더별 차별화 청킹 적용
Sat-Sun: 2,945개 파일 전체 인덱싱 + 검증

목표: embedding-config 경험 통합 + 전체 인덱싱 완료
#+end_example

*** Week 3: Hybrid Search (ELISA 패턴)
:PROPERTIES:
:CUSTOM_ID: week-3-hybrid-search-elisa-패턴
:END:
#+begin_example
Mon-Tue: RRF SQL 함수 작성
Wed-Thu: Vector/FTS/Hybrid 품질 비교
Fri: gptel 도구 통합 (Claude Code)
Sat-Sun: 문서화 + memex-kb 역적용 계획

목표: Hybrid Search 완성 + 경험 문서화
#+end_example

--------------

** 🔄 memex-kb 역적용 계획 (3주 후)
:PROPERTIES:
:CUSTOM_ID: memex-kb-역적용-계획-3주-후
:END:
*** "Org-mode 경험 → Denote Markdown"
:PROPERTIES:
:CUSTOM_ID: org-mode-경험-denote-markdown
:END:
#+begin_src yaml
3주 실험 완료 후:
  ✅ John Kitchin 패턴 검증 (한글 환경)
  ✅ Heading 별도 테이블 효과 확인
  ✅ 2-Tier 검색 속도 측정
  ✅ 한글 특화 전략 확립
  ✅ embedding-config 통합 검증
  ✅ Hybrid Search 품질 측정

memex-kb v2.0 역적용:
  1. Org 청킹 → Markdown 청킹 (# 헤딩)
  2. org_headings → memex_headings (Markdown용)
  3. 한글 특화 로직 통합
  4. Denote Markdown 파싱
  5. gptel 도구 패턴
  6. 검증된 폴더별 설정

가치:
  Org-mode: ~/org/ (실전 검증 완료)
  Markdown: memex-kb (Legacy 변환, 동일 전략)

  → 두 방향 모두 지원!
  → Org 경험이 memex-kb 품질 보장!
#+end_src

--------------

** 🔗 관련 문서 & 리소스
:PROPERTIES:
:CUSTOM_ID: 관련-문서-리소스
:END:
*Claude-memory (리소스)*: -
~/claude-memory/resources/20251009T130000--org-헤딩-시맨틱-검색-claude-에이전트-통합-가이드__solution_claude_agent_org_heading.md -
~/claude-memory/resources/20251009T122000--khoj-vs-emacs-rag-libsql-에이전트-활용-비교분석__analysis_claude_agent_rag.md

*embedding-config (검증된 경험)*: -
~/repos/gh/embedding-config/org_embedding/ - process_org_garden.py
(539줄, 2,945개 성공) - ORG_GARDEN_EMBEDDING_STRATEGY.md (폴더별 청킹) -
ORG_GARDEN_EMBEDDING_RESULT.md (8,310 청크) - KNOWLEDGE_HIERARCHY.md
(meta → bib → journal → notes)

*emacs-rag-libsql (John Kitchin)*: - ~/repos/3rd/emacs-rag-libsql/ -
chunking.py (66줄) - database.py (854줄, Heading 별도 테이블) -
readme.org, software-design.org

*ELISA (s-kostyaev)*: - ~/repos/3rd/elisa/ - elisa.el (~30줄 청킹, RRF
SQL)

*비교 (제외)*: - ~/repos/3rd/chonkie/ (33,777줄, 참고만)

--------------

** 📝 핵심 결론
:PROPERTIES:
:CUSTOM_ID: 핵심-결론
:END:
*** "Org-mode 우선 → 경험 검증 → memex-kb 역적용"
:PROPERTIES:
:CUSTOM_ID: org-mode-우선-경험-검증-memex-kb-역적용
:END:
*1. Org-mode 먼저*:

#+begin_example
~/org/ 1,400+ 파일
    ↓ John Kitchin + embedding-config + ELISA
실전 경험 (3주 실험)
    ↓ 한글 특화
나만의 전략 확립
#+end_example

*2. 전문가 따라하기*:

#+begin_example
✅ John Kitchin: Heading 별도 테이블, 2-Tier 검색, gptel
✅ embedding-config: 폴더별 차별화, 2,945개 검증
✅ ELISA: Hybrid Search (RRF), SQLite
#+end_example

*3. 한글 특화*:

#+begin_example
✅ mxbai-embed-large (1024-dim)
✅ Denote 파싱 (한글 제목 + 영어 태그)
✅ FILETAGS 한글/영어 통합
✅ 한글 토큰 계산 (선택적)
#+end_example

*4. memex-kb 역적용*:

#+begin_example
Org 경험 검증 (3주)
    ↓
Markdown 변환 (동일 전략)
    ↓
memex-kb v2.0 (Legacy → RAG-ready)
#+end_example

--------------

*최종 업데이트*: 2025-10-16T14:00:00+09:00 *다음 단계*: Phase 1 실험
시작 (emacs-rag-libsql + 한글 모델)

--------------

*"Emacs 전문가를 따라하되, 한글 환경에 맞게 개선한다"* *"~/org/에서
경험을 쌓고, memex-kb에 역적용한다"* *"간단함, 통제, 검증 - 이것이
실용주의다"*
