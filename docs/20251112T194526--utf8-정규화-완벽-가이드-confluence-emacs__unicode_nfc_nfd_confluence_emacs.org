#+title:      UTF-8 정규화 완벽 가이드: Confluence & Emacs
#+date:       [2025-11-12 Tue 19:45]
#+filetags:   :unicode:nfc:nfd:confluence:emacs:
#+identifier: 20251112T194526
#+export_file_name: 20251112T194526.md

* UTF-8 정규화 완벽 가이드: Confluence & Emacs :ULTIMATE:

이맥스를 사용하지 않더라도 터미널 환경에서 AI 에이전트와 협업하려면
반드시 마주칠 수 있는 귀한 정보입니다. UTF-8 정규화 문제의 완벽한 해결책입니다.

** 💡 왜 이것이 Memex-KB의 핵심인가?

변환 도구는 많습니다. Pandoc, Notion Exporter, Confluence API...
하지만 *문자 인코딩 하나*를 제대로 처리하지 못하면 모든 것이 무너집니다.

- 한글이 깨지면? → 검색 불가능
- NFD/NFC 혼재? → 파일 손상, 편집 불가능
- Quoted-printable 오류? → 데이터 유실

*memex-kb는 "변환"이 아닌 "완벽한 변환"을 추구합니다.*
이것이 단순 도구와 RAG 파이프라인 입구의 차이입니다.

🎯 *철학*:
- 첫 번째 변환에서 완벽하게 처리
- 인코딩 문제로 인한 데이터 손실 Zero
- RAG 임베딩 품질을 첫 단계에서 확보

** 1️⃣ 이슈 #1: Confluence 문서 변환 시 한글 깨짐

*** 문제 상황

Confluence에서 Export한 =.doc= 파일을 pandoc으로 변환 시:
- 한글이 유니코드 escape 형식(=EC=97=B0...)과 섞여서 표시
- 이맥스에서 열면 읽을 수 없는 상태

#+BEGIN_EXAMPLE
# IoT Core Device =EC=97=B0=EB=8F=99=EA=B7=9C=EA=B2=A9=EC=84=9C v1.13
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                   이 부분이 "연동규격서"여야 하는데 깨짐
#+END_EXAMPLE

*** 원인 분석

1. *Confluence Export 형식*:
   - =.doc= 확장자이지만 실제로는 =MIME multipart/related= 메시지
   - HTML이 =quoted-printable= 인코딩으로 포함됨
   - Soft line break (=으로 끝나는 줄)가 포함되어 있음

2. *Quoted-Printable 문제*:
   #+BEGIN_SRC text
   # 원본 (quoted-printable)
   =EC=97=B0=EB=8F=90=   <- soft line break (=)
   =EA=B7=9C=EA=B2=A9

   # Python quopri.decodestring() 사용 시
   한글이 일부만 디코딩되고 일부는 그대로 남음
   #+END_SRC

3. *올바른 방법*:
   - Python =email= 모듈로 MIME 파싱
   - HTML 파트를 UTF-8로 추출
   - Pandoc으로 Markdown 변환

*** 해결 방법

**** 완벽한 변환 파이프라인

파일: =~/repos/gh/memex-kb/scripts/confluence_to_markdown.py=

#+BEGIN_SRC python
#!/usr/bin/env python3
"""
Confluence to Markdown Converter for Memex-KB
==============================================

완벽한 한글 처리와 깨끗한 Markdown 변환
"""

import email
import subprocess
import unicodedata
from email import policy
from pathlib import Path

class ConfluenceConverter:
    def extract_html_from_mime(self, doc_file: Path) -> str:
        """MIME 메시지에서 HTML 추출"""
        with open(doc_file, 'rb') as f:
            msg = email.message_from_binary_file(f, policy=policy.default)

        # HTML 파트 찾기
        for part in msg.walk():
            if part.get_content_type() == 'text/html':
                return part.get_content()  # UTF-8 문자열

        raise ValueError("HTML 파트를 찾을 수 없습니다.")

    def convert_html_to_markdown(self, html: str) -> str:
        """Pandoc으로 변환"""
        # ... pandoc 실행 로직 ...
        return markdown

    def clean_markdown(self, markdown: str) -> str:
        """후처리: fenced div 제거, 코드 블록 정리"""
        import re

        # 1. Section 구분자 제거
        markdown = re.sub(r'^:{3,}.*Section\d+.*$', '', markdown, flags=re.MULTILINE)

        # 2. Fenced div 제거
        markdown = re.sub(r'^:{3,}\s*{[^}]*}\s*$', '', markdown, flags=re.MULTILINE)
        markdown = re.sub(r'^:{3,}\s*$', '', markdown, flags=re.MULTILINE)

        # 3. 헤딩 ID 제거
        markdown = re.sub(r'\s+{#[^}]+}', '', markdown)

        # 4. 코드 블록 정리
        markdown = re.sub(
            r'```\s*\{\.syntaxhighlighter-pre[^}]+\}',
            '```json',
            markdown
        )

        # 5. **핵심**: NFD → NFC 정규화
        markdown = unicodedata.normalize('NFC', markdown)

        return markdown
#+END_SRC

**** 사용 방법

#+BEGIN_SRC bash
# 단일 파일
python3 scripts/confluence_to_markdown.py document.doc

# 일괄 변환
python3 scripts/confluence_to_markdown.py --batch input_dir/ output_dir/

# 자세한 로그
python3 scripts/confluence_to_markdown.py -v document.doc
#+END_SRC

**** 변환 결과

| 항목           | Before                        | After                  |
|----------------+-------------------------------+------------------------|
| 파일 크기      | 1.1 MB                        | 178 KB                 |
| 한글 인코딩    | =EC=97=B0... (깨짐)           | 연동규격서 (완벽)      |
| Fenced div     | 554개                         | 0개                    |
| 코드 블록      | 복잡한 속성                   | 깨끗한 \`\`\`json         |
| NFD 조합형     | 혼재                          | NFC 완성형 (100%)      |

** 2️⃣ 이슈 #2: Termux Emacs 실시간 한글 입력 문제

*** 문제 상황 (가장 심각한 이슈!)

*Termux 터미널 환경에서 Emacs nw 모드로 실행 시*:
- 한글 입력 후 *스페이스 키를 누르면* 입력된 글자가 NFD(분해형)으로 변환됨
- 파일에 저장되면 NFC(완성형)와 NFD(분해형)가 혼재
- 검색 불가능, 편집 불가능, 파일 손상

#+BEGIN_EXAMPLE
입력: "안녕하세요" + 스페이스
결과: "ㅇㅏㄴㄴㅕㅇ하세요"  <- 첫 두 글자가 분해됨!

유니코드:
- 정상(NFC): U+C548 U+B155 U+D558 U+C138 U+C694
- 문제(NFD): U+1109 U+1161 U+11AB U+1102 U+1167 U+11BC U+D558 U+C138 U+C694
                ^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^
                초성+중성+종성 분리    초성+중성+종성 분리
#+END_EXAMPLE

*** 원인 분석 (UTF-8 Normalization)

1. *NFD vs NFC*:
   #+BEGIN_SRC text
   NFC (Normalization Form Composed):
   "한" = U+D55C (1개 코드 포인트, 완성형)

   NFD (Normalization Form Decomposed):
   "한" = U+1112(ㅎ) + U+1161(ㅏ) + U+11AB(ㄴ)  (3개 코드 포인트, 조합형)
   #+END_SRC

2. *macOS/Termux 특성*:
   - macOS: 파일시스템이 NFD 사용 (HFS+)
   - Termux: Android IME가 NFD로 입력
   - Windows: NFC 사용

3. *스페이스 입력 시 발생 이유*:
   - Termux IME가 조합 완료 시점에 NFD로 변환
   - 이맥스가 그대로 받아서 버퍼에 저장
   - 저장 전까지 변환 기회 없음

*** 해결 방법 (실시간 변환!)

**** 핵심 아이디어

- =after-change-functions= 훅으로 *입력 즉시* NFD → NFC 변환
- 디바운스로 성능 최적화 (0.1초 지연)
- 저장 전 / 파일 열기 시에도 변환 (안전망)

**** 구현

파일: =~/.doom.d/+korean-input-fix.el=

#+BEGIN_SRC elisp
;;; ~/.doom.d/+korean-input-fix.el -*- lexical-binding: t; -*-

(require 'ucs-normalize)

;;; 1. 한글 자모 패턴 정의

(defconst korean-jamo-pattern
  (concat "[\u1100-\u115F\uA960-\uA97C]"  ; 초성
          "[\u1160-\u11A7\uD7B0-\uD7C6]"  ; 중성
          "[\u11A8-\u11FF\uD7CB-\uD7FB]?") ; 종성 (선택)
  "한글 조합형 자모 전체 패턴")

;;; 2. 실시간 변환 (핵심!)

(defvar-local korean/nfc-timer nil
  "NFC 변환 디바운스 타이머")

(defun korean/after-change-nfc-normalize (beg end _len)
  "텍스트 변경 후 자동으로 NFD → NFC 정규화."
  ;; 디바운스: 0.1초 이내 연속 입력은 마지막만 처리
  (when korean/nfc-timer
    (cancel-timer korean/nfc-timer))

  (setq korean/nfc-timer
        (run-with-idle-timer
         0.1 nil
         (lambda ()
           (when (buffer-live-p (current-buffer))
             (save-excursion
               (save-match-data
                 ;; 변경된 영역 + 앞뒤 10자 검사
                 (let* ((search-begin (max (point-min) (- beg 10)))
                        (search-end (min (point-max) (+ end 10)))
                        (inhibit-modification-hooks t))
                   (goto-char search-begin)
                   ;; 한글 자모 패턴 찾기
                   (while (re-search-forward korean-jamo-pattern search-end t)
                     (ucs-normalize-NFC-region (match-beginning 0) (match-end 0)))))))))))

;;; 3. 마이너 모드

(define-minor-mode korean-nfc-mode
  "한글 NFD → NFC 자동 변환 마이너 모드."
  :lighter " 한"
  :global nil
  (if korean-nfc-mode
      (progn
        (add-hook 'after-change-functions #'korean/after-change-nfc-normalize nil t)
        (add-hook 'before-save-hook #'korean/before-save-nfc-normalize nil t))
    (progn
      (remove-hook 'after-change-functions #'korean/after-change-nfc-normalize t)
      (remove-hook 'before-save-hook #'korean/before-save-nfc-normalize t))))

;;; 4. 자동 활성화 (Termux 감지)

(defun korean/enable-nfc-mode-if-needed ()
  "Termux 환경이면 자동으로 korean-nfc-mode 활성화"
  (when (and (not (display-graphic-p))
             (or (getenv "TERMUX_VERSION")
                 (string-match-p "termux" (or (getenv "PREFIX") ""))))
    (korean-nfc-mode 1)))

(add-hook 'text-mode-hook #'korean/enable-nfc-mode-if-needed)
(add-hook 'prog-mode-hook #'korean/enable-nfc-mode-if-needed)

(provide '+korean-input-fix)
#+END_SRC

**** 설정 (Doom Emacs)

=~/.doom.d/config.el= 에 추가:

#+BEGIN_SRC elisp
(load! "+korean-input-fix")
#+END_SRC

** 🎯 성능 최적화 및 주의사항

*** 성능 고려사항

1. *디바운스 타이머*:
   - 0.1초 지연으로 과도한 실행 방지
   - 사용자가 타이핑 중일 때는 대기
   - 타이핑 멈춘 후 0.1초 후 실행

2. *제한된 영역 검사*:
   - 변경된 위치 ±10자만 검사
   - 전체 버퍼 검사 X (성능 저하 방지)

3. *재귀 방지*:
   - =inhibit-modification-hooks t= 설정
   - 변환 중 다시 훅 호출 방지

*** 검증 방법

#+BEGIN_SRC elisp
;; 1. 한글 입력 테스트
안녕하세요 스페이스를 누르면 자동 변환됨

;; 2. 버퍼 전체 수동 변환
M-x korean/convert-jamo-to-syllable

;; 3. 모드 확인
M-x describe-mode
;; "korean-nfc-mode" 표시되는지 확인
#+END_SRC

** 📚 참고 자료

*** 동일 문제 보고

1. [[https://github.com/wezterm/wezterm/issues/2482][WezTerm #2482]]: Korean NFD vs NFC
2. [[https://github.com/org-roam/org-roam/issues/1423][org-roam #1423]]: Hangul(Korean letter) is not supported
3. [[https://jyun.rbind.io/post/utf_hfs/][Jonghyun Yun Blog]]: How to fix when Emacs in OS X displays decomposed Korean characters

*** Unicode 정규화 표준

- [[https://www.unicode.org/reports/tr15/][UAX #15: Unicode Normalization Forms]]
- [[https://www.unicode.org/L2/L2009/09052-tr47.html][UTR #47: Korean Processing Forms]]

*** 한글 자모 유니코드 범위

| 구분   | 범위            | 설명         |
|--------+-----------------+--------------|
| 초성   | U+1100 ~ U+115F | Choseong     |
| 중성   | U+1160 ~ U+11A7 | Jungseong    |
| 종성   | U+11A8 ~ U+11FF | Jongseong    |
| 완성형 | U+AC00 ~ U+D7A3 | 한글 음절    |
| 호환   | U+3130 ~ U+318F | 호환 자모    |

** 🚀 결론 및 Memex-KB 철학

*** 완벽한 한글 처리가 가능합니다

1. *Confluence 문서*: MIME 파싱 → 깨끗한 Markdown
2. *실시간 입력*: NFD → NFC 자동 변환 (0.1초 디바운스)
3. *저장/열기*: 안전망으로 이중 체크

*** Memex-KB의 독창적 가치

#+BEGIN_QUOTE
"변환 도구는 많지만, 완벽한 변환은 드물다"

- 첫 번째 변환에서 인코딩 문제 해결
- 데이터 손실 Zero
- RAG 파이프라인 품질을 첫 단계에서 확보
#+END_QUOTE

| 일반 도구          | Memex-KB                      |
|--------------------+-------------------------------|
| 변환만 함          | 완벽한 변환 + 검증            |
| 한글 깨짐 허용     | 한글 100% 보존 (NFD/NFC)      |
| 후처리 필요        | 첫 변환에서 완료              |
| RAG 품질 저하      | RAG-ready 상태 보장           |

*이맥스가 아니더라도* 터미널 환경에서 AI 에이전트와 협업 시
이 정보는 매우 귀중합니다. UTF-8 정규화 문제의 완벽한 해결책입니다.

** 📦 관련 파일

- Python 스크립트: =~/repos/gh/memex-kb/scripts/confluence_to_markdown.py=
- Emacs 설정: =~/.doom.d/+korean-input-fix.el=
- 상세 문서: [[file:/storage/emulated/0/Documents/sync/org/notes/20250125T190619--llm-조합형-자모를-완성형-음절-변환-함수__llmlog_unicode.org][20250125T190619--llm-조합형-자모를-완성형-음절-변환-함수__llmlog_unicode.org]]

** 🏷️ 태그

#unicode #nfc #nfd #confluence #emacs #termux #korean #한글 #정규화 #변환
#memex-kb #rag #pipeline #encoding #utf8
